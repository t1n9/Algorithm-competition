## 递归

### 数学归纳法

1.验证p(1)成立

2.证明如果p(k)成立，那么p(k+1)也成立

3.联合1、2，证明p(1)->p(n)成立

### 递归函数设计三个部分

**1.给递归函数一个明确的语义**

先不考虑怎么实现，但要给一个**明确**的解释

2.实现边界条件是的程序逻辑

3.假设递归函数调用返回结果是正确的，实现本层函数逻辑

例：递归求阶乘

```c++
int f(int n){//f(n)代表n的阶乘
    if(n==1)return 1;//边界条件
    return f(n-1)*n;//假设f(n-1)是正确的，实现f(n)=f(n-1)*n
}
```

# 数据结构=结构定义+结构操作

## 顺序表⭐

### 定义

连续存储区+表大小size+元素多少count

### 操作

#### 插入：

后移、赋值、count++

#### 删除：

前移，count++

#### 扩容：

size*=2

## 链表⭐

多个节点串联在一起，单个节点包含自身信息+下一个节点地址

### 操作

#### 删除：

1->2->3->4

删除2，仅需将1->3即可

#### 插入：

0->1->2->3->4->5

在3处插入**0**：将0指向3，再将2(3的前一个元素)指向0即可

```c++
Node *p=2;
Node 0->next=3;
p->next=0;
```

注意：要考虑头插情况。

#### 有头）插入：

创建虚拟头.next=原链表头节点

dummyhead->0->1->2->3->4->5

在3处插入**0**：p指向dummyhead，p往后走3步，0指向3，p指向0即可。

<u>**注意**</u>：返回的是dummyhead.next。

### 类型

无头链表：头部只是一个指针

有头链表：头部有存储信息的区域但是不存储信息（更方便）

### 单向循环链表

head指向循环链表最后一个节点，即head->next=*(index=0)

### 双向链表

结构定义中多了一个指向前一个节点的per指针

## 树⭐

单向链表结构是树形结构的特例

### 深度、高度

深度：从根节点往下数

高度：从最高层叶子节点往上数

1.树的深度与高度相等，都为整棵树最高的层数，从1往上数

2.节点的深度是以根为0往下数，高度是以最高层叶子节点为0往上数

### （出）度、入度

出度/度：当前节点的**子树/子节点**的数量

入度：其他节点指向当前节点的数量（0/1，不经常讨论）

### 注意：

节点数量=边数+1

### 二叉树

二叉树中度为0的节点比度为2的节点多1个

完全二叉树：排序完整

左孩子=父节点* 2+1；右孩子=父节点*2+2

满二叉树：除了叶子节点，其他节点都有左右孩子节点

完美二叉树：每一层都是满的

### 遍历

前序：根-左-右

中序：左-根-右

后序：左-右-根
